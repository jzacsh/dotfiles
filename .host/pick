#!/bin/bash

forest_runtime_dir="$XDG_RUNTIME_DIR"/"$(whoami)".dotfiles.management.d

# help ensure dotfiles for task "$1" only run once per boot
has_run_forest() (
  set -eou pipefail
  mkdir -p "$forest_runtime_dir"

  local dots_subset="$1"
  local has_run_semaphore="$forest_runtime_dir"/"$dots_subset"
  if [[ -r "$has_run_semaphore" ]]; then
    return 0 # _has_ run
  else
    log_jzdots info \
      'dotfile forest not yet run for "%s", running now...\n' "$dots_subset"
    date --iso-8601=ns > "$has_run_semaphore"
    return 1 # has _not_ run
  fi
)

# TODO this is still experimental; no idea if DBUS_SESSION_BUS_ADDRESS is
# really a reliable signal; not sure _which_ signals are really reliable.
# just trying to make sure i don't see useless errors when i login via SSH
# and/or a seated TTY
is_desktop_env() (
  [[ -n "$DISPLAY" ]] && [[ -n "$DBUS_SESSION_BUS_ADDRESS" ]]
)

# useful catalog of some env. variables in this space:
#   https://wiki.archlinux.org/index.php/Environment_variables#Examples
get_desktop_env() (
  local deEnv="$DE"
  [[ -n "$DE" ]] || deEnv="$DESKTOP_SESSION"
  echo "$deEnv"
)

src_this() {
  local target="$1"
  if ! [[ -s "$target" ]] || ! [[ -r "$target" ]] || ! [[ -f "$target" ]];then
    log_jzdots warn '~/%-15s not readable, non-empty file\n' "${target/$HOME\/}"
    return # don't error return; don't want to stop my own shell login
  fi
  source "$target"
}

is_same_file() ( [[ "$(readlink --canonicalize "$1")" = "$(readlink --canonicalize "$2")" ]]; )

# Ensures a personal dotfile ($1) is used in your system, where you expect ($2).
#
# Ultimately equivalent to `ln -svf "$1" "$2"`
#
# $1 = path to a tracked file in the dotfile forest
# $2 = path to a file somewhere on your system you want to ensure is _actually_
#      just a symlink to $1
host_forest_link() (
  local dotFile="$1" landing="$2" implied="$landing"

  if [[ -L "$landing" ]] && is_same_file "$dotFile" "$landing"; then
    return
  elif [[ -d "$landing" ]]; then
    implied="${landing%/}"/"$(basename "$dotFile")"
    if is_same_file "$dotFile" "$implied"; then
      return
    fi
  fi

  if [[ -s "$landing" ]];then
    local backup="$(mktemp --tmpdir=  'host_forest_link_XXXXXXXX.backup')"
    cp -d -v "$implied" "$backup"
    log_jzdots warn 'overwriting target at %s, backup is at %s\n' \
      "$implied" "$backup" >&2
  fi
  ln -svf "$dotFile" "$landing"
)

src_all() {
    local distroSuffix hostSuffix deSuffix domainSuffix

    #
    # generic distro-specific config
    #
    if [[ -f /etc/arch-release ]]; then
      distroSuffix=arch
    elif [[ -f /etc/lsb-release ]]; then
      distroSuffix="$(awk -F'=' '/^DISTRIB_ID/{print tolower($2)}' /etc/lsb-release)"
    elif [[ -f /etc/debian_version ]];then
      distroSuffix=debian
    fi

    #
    # host-specific configuration
    #
    hostSuffix="${HOSTNAME/.*/}" #mimic `hostname -s`

    #
    # DE(GUI)-specific configuration
    #
    if is_desktop_env;then
      deSuffix="$(get_desktop_env)"

      # provide a fallback with some basics that are X11 "specific" but not
      # really DE-specific
      [[ -n "$deSuffix" ]] || deSuffix=_jzacshcatchall
    fi

    #
    # domain-specific configuration
    #
    domainSuffix="$(hostname --domain)"

    #
    # actually source everything all at once
    #
    local dir="$HOME/.host"

    log_jzdots info \
      '~/.host forest-walk (dir="%s"): distro="%s", host="%s", DE="%s" domain="%s"\n' \
       "$forest_runtime_dir" \
       "$distroSuffix" "$hostSuffix" \
       "${deSuffix:-n/a}" "${domainSuffix:-n/a}"

    has_run_forest distro ||
      src_this "${dir}/distro.${distroSuffix}"
    has_run_forest host ||
      src_this "${dir}/host.${hostSuffix}"
    { [[ -z "$deSuffix" ]] || has_run_forest deskenv; } ||
      src_this "${dir}/deskenv.${deSuffix}"
    { [[ -z "$domainSuffix" ]] || has_run_forest domain; } ||
      src_this "${dir}/domain.${domainSuffix}"
}

src_all
unset src_all src_this has_run_forest forest_runtime_dir is_desktop_env get_desktop_env host_forest_link is_same_file
